{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"The Bitcoin Development Kit","text":"<p>The Bitcoin Development Kit (BDK) project was created to provide well engineered and reviewed components for building bitcoin-based applications.</p> <p>The core components of BDK are written in the Rust language and live in the <code>bitcoindevkit/bdk</code> repository. The core BDK components are built upon the excellent <code>rust-bitcoin</code> and <code>rust-miniscript</code> crates.</p> <p>The BDK team also maintains the <code>bitcoindevkit/bdk-ffi</code> repository which provide cross-platform versions of the high level BDK APIs. Current supported platforms are: Kotlin (Android, Linux, macOS), Swift (iOS, macOS), and Python (Linux, macOS, Windows).</p> <p>Warning</p> <p>The BDK developers are in the process of rewriting major components of the software to be released in an upcoming <code>1.0</code> version. BDK 1.0 is still under active development and should be considered \"alpha\" quality. This means APIs may change and full testing and documentation has not been completed. For current status and release timeline please see the <code>bdk</code> project repository.</p> <p>The <code>bitcoindevkit/bdk-ffi</code> project has not yet been updated to use the new <code>BDK 1.0</code> crates. For current status and timeline for bdk-ffi, see the <code>bdk-ffi</code> project repository.</p>"},{"location":"architecture/design/","title":"Design of the BDK Ecosystem","text":"<p>The pages in this section intend to speak to why the BDK crates are designed the way they are, and the relationship between them.</p>"},{"location":"cookbook/full-wallet/","title":"Full Wallet Example","text":"<p>This page illustrates core wallet functionality, including:</p> <ul> <li>Generating descriptors</li> <li>Wallet creation, persistence, and loading</li> <li>Full scan and light weight sync</li> <li>Creating and broadcasting a transaction</li> </ul> <p>Tip</p> <p>The logic for this page is split between 2 separate examples in the examples source code. One to create descriptors and a second for everything else.If you are following along with the code examples you will need to copy and paste your private descriptors you get from the first example into the second. We leave descriptor creation in a separate example because bdk does not handle private descriptor (or private key) storage, that is up to the wallet developer.</p>"},{"location":"cookbook/full-wallet/#generating-descriptors","title":"Generating Descriptors","text":"<p>First we create signet descriptors for our wallet.</p> examples/rust/descriptors/src/main.rs<pre><code>let mut seed: [u8; 32] = [0u8; 32];\nrand::thread_rng().fill_bytes(&amp;mut seed);\n\nlet network: Network = Network::Signet;\nlet xprv: Xpriv = Xpriv::new_master(network, &amp;seed).unwrap();\nprintln!(\"Generated Master Private Key:\\n{}\\nWarning: be very careful with private keys when using MainNet! We are logging these values for convenience only because this is an example on SigNet.\\n\", xprv);\n\nlet (descriptor, key_map, _) = Bip86(xprv, KeychainKind::External)\n    .build(Network::Signet)\n    .expect(\"Failed to build external descriptor\");\n\nlet (change_descriptor, change_key_map, _) = Bip86(xprv, KeychainKind::Internal)\n    .build(Network::Signet)\n    .expect(\"Failed to build internal descriptor\");\n\nlet descriptor_string_priv = descriptor.to_string_with_secret(&amp;key_map);\nlet change_descriptor_string_priv = descriptor.to_string_with_secret(&amp;change_key_map);\n</code></pre> <p>Notice we are creating private descriptors here in order to sign transactions later on.</p>"},{"location":"cookbook/full-wallet/#full-scan-and-address-generation-first-run","title":"Full Scan and Address Generation (First Run)","text":"<p>Next, lets use those descriptors to load up our wallet. Replace the placeholder descriptors in the <code>full-wallet</code> example with your private descriptors:</p> examples/rust/full-wallet/src/main.rs<pre><code>const DESCRIPTOR_PRIVATE_EXTERNAL: &amp;str = \"[your private external descriptor here ...]\";\nconst DESCRIPTOR_PRIVATE_INTERNAL: &amp;str = \"[your private internal descriptor here ...]\";\n// Example private descriptors\n// const DESCRIPTOR_PRIVATE_EXTERNAL: &amp;str = \"tr(tprv8ZgxMBicQKsPdJuLWWArdBsWjqDA3W5WoREnfdgKEcCQB1FMKfSoaFz9JHZU71HwXAqTsjHripkLM62kUQar14SDD8brsmhFKqVUPXGrZLc/86'/1'/0'/0/*)#fv8tutn2\";\n// const DESCRIPTOR_PRIVATE_INTERNAL: &amp;str = \"tr(tprv8ZgxMBicQKsPdJuLWWArdBsWjqDA3W5WoREnfdgKEcCQB1FMKfSoaFz9JHZU71HwXAqTsjHripkLM62kUQar14SDD8brsmhFKqVUPXGrZLc/86'/1'/0'/1/*)#ccz2p7rj\";\n</code></pre> <p>We are going to run this example twice. On the first run it will do a full scan for your wallet, persist that chain data, generate a new address for you, and display your current wallet balance, it will then attempt to build a transaction, but will fail becuase we don't have any funds yet. We will use the new address (from the first run) to request funds from the Mutinynet faucet so we can build a transaction on the second run. On the second run it will load the data from the previous run, do a light weight sync to check for updates (no need to repeat the full scan), and then build and broadcast a transaction. Let's go through this step by step.</p> examples/rust/full-wallet/src/main.rs<pre><code>let mut conn = Connection::open(DB_PATH)?;\n\nlet wallet_opt = Wallet::load()\n    .descriptor(KeychainKind::External, Some(DESCRIPTOR_PRIVATE_EXTERNAL))\n    .descriptor(KeychainKind::Internal, Some(DESCRIPTOR_PRIVATE_INTERNAL))\n    .extract_keys()\n    .check_network(Network::Signet)\n    .load_wallet(&amp;mut conn)?;\n\nlet (mut wallet, is_new_wallet) = if let Some(loaded_wallet) = wallet_opt {\n    (loaded_wallet, false)\n} else {\n    (Wallet::create(DESCRIPTOR_PRIVATE_EXTERNAL, DESCRIPTOR_PRIVATE_INTERNAL)\n        .network(Network::Signet)\n        .create_wallet(&amp;mut conn)?, true)\n};\n</code></pre> <p>In the quickstart example we simply used an in-memory wallet, with no persistence. But here we are saving wallet data to a file. Notice that we are providing our private descriptors during wallet load. This is because bdk never stores private keys, that responsibility is on the wallet developer (you). The data we are loading here does not include the private keys, but we want our wallet to have signing capabilities, so we need to provide our private descriptors during wallet load. If we get a wallet back from the load attempt, we'll use that, otherwise we'll create a new one. Since this is our first run nothing will be loaded and a new wallet will be created.</p> examples/rust/full-wallet/src/main.rs<pre><code>let client: esplora_client::BlockingClient = Builder::new(\"https://mutinynet.com/api\").build_blocking();\n// Sync the wallet\nif is_new_wallet {\n    // Perform a full scan\n    println!(\"Performing full scan...\");\n    let full_scan_request: FullScanRequestBuilder&lt;KeychainKind&gt; = wallet.start_full_scan();\n    let update: FullScanResult&lt;KeychainKind&gt; = client.full_scan(full_scan_request, STOP_GAP, PARALLEL_REQUESTS)?;\n    wallet.apply_update(update).unwrap();\n} else {\n    // Perform a regular sync\n    println!(\"Performing regular sync...\");\n    let sync_request: SyncRequestBuilder&lt;(KeychainKind, u32)&gt; = wallet.start_sync_with_revealed_spks();\n    let update: SyncResult = client.sync(sync_request, PARALLEL_REQUESTS)?;\n    wallet.apply_update(update).unwrap();\n};\nwallet.persist(&amp;mut conn)?;\n</code></pre> <p>Next we'll fetch data from our blockchain client. On the first run, we don't yet have any data, so we need to do a full scan. We then persist the data from the scan. Finally, we'll print out an address that we can use to request funds. You should also see the current balance printed out, it should be 0 since this is a brand new wallet. Note that we persist the wallet after generating the new address; this is to avoid re-using the same address as that would compromise our privacy (on subsequent runs you'll notice the address index incremented).</p> examples/rust/full-wallet/src/main.rs<pre><code>// Reveal a new address from your external keychain\nlet address: AddressInfo = wallet.reveal_next_address(KeychainKind::External);\nprintln!(\"Generated address {} at index {}\", address.address, address.index);\nwallet.persist(&amp;mut conn)?;\n</code></pre> <p>The process will then error out, indicating we don't have enough funds to send a transaction.</p>"},{"location":"cookbook/full-wallet/#request-satoshis-from-the-mutinynet-faucet","title":"Request satoshis from the Mutinynet faucet","text":"<p>We can now use our new address to request some sats from the Mutinynet faucet. After requesting sats, you can view the transaction in their Mempool Explorer instance (click the link on the faucet confirmation page or put the txid in the search bar of the mempool explorer). After a minute or so you should see the transaction confirmed. We can also re-run the <code>full-wallet</code> example and see that our wallet now has some funds!</p>"},{"location":"cookbook/full-wallet/#load-sync-and-send-a-transaction-second-run","title":"Load, Sync, and Send a Transaction (Second Run)","text":"<p>Now that we have some funds, we can re-run the <code>full-wallet</code> example. Since we persisted data from the previous run, this time our wallet will be loaded. You do not need to provide descriptors to load wallet data, however, if you don't you will not have signing capabilities, so here we do provide our private descriptors in the loading process:</p> examples/rust/full-wallet/src/main.rs<pre><code>let mut conn = Connection::open(DB_PATH)?;\n\nlet wallet_opt = Wallet::load()\n    .descriptor(KeychainKind::External, Some(DESCRIPTOR_PRIVATE_EXTERNAL))\n    .descriptor(KeychainKind::Internal, Some(DESCRIPTOR_PRIVATE_INTERNAL))\n    .extract_keys()\n    .check_network(Network::Signet)\n    .load_wallet(&amp;mut conn)?;\n\nlet (mut wallet, is_new_wallet) = if let Some(loaded_wallet) = wallet_opt {\n    (loaded_wallet, false)\n} else {\n    (Wallet::create(DESCRIPTOR_PRIVATE_EXTERNAL, DESCRIPTOR_PRIVATE_INTERNAL)\n        .network(Network::Signet)\n        .create_wallet(&amp;mut conn)?, true)\n};\n</code></pre> <p>Since we already have some data from the previous run, it will not do a full scan, but only a sync which is faster and less data intensive.</p> examples/rust/full-wallet/src/main.rs<pre><code>let client: esplora_client::BlockingClient = Builder::new(\"https://mutinynet.com/api\").build_blocking();\n// Sync the wallet\nif is_new_wallet {\n    // Perform a full scan\n    println!(\"Performing full scan...\");\n    let full_scan_request: FullScanRequestBuilder&lt;KeychainKind&gt; = wallet.start_full_scan();\n    let update: FullScanResult&lt;KeychainKind&gt; = client.full_scan(full_scan_request, STOP_GAP, PARALLEL_REQUESTS)?;\n    wallet.apply_update(update).unwrap();\n} else {\n    // Perform a regular sync\n    println!(\"Performing regular sync...\");\n    let sync_request: SyncRequestBuilder&lt;(KeychainKind, u32)&gt; = wallet.start_sync_with_revealed_spks();\n    let update: SyncResult = client.sync(sync_request, PARALLEL_REQUESTS)?;\n    wallet.apply_update(update).unwrap();\n};\nwallet.persist(&amp;mut conn)?;\n</code></pre> <p>Now that we have funds, let's prepare to send a transaction. We need to decide where to send the funds and how much to send.We will send funds back to the mutiny faucet return address. It's good practice to send test sats back to the faucet when you're done using them.</p> examples/rust/full-wallet/src/main.rs<pre><code>// Use the Mutinynet faucet return address\nlet address = Address::from_str(\"tb1qd28npep0s8frcm3y7dxqajkcy2m40eysplyr9v\")\n    .unwrap()\n    .require_network(Network::Signet)\n    .unwrap();\n\nlet send_amount: Amount = Amount::from_sat(5000);\n</code></pre> <p>Here we are preparing to send 5000 sats back to the mutiny faucet (it's good practice to send test sats back to the faucet when you're done using them).</p> <p>Finally we are ready to build, sign, and broadcast the transaction:</p> examples/rust/transaction/src/main.rs<pre><code>// Transaction Logic\nlet mut tx_builder = wallet.build_tx();\ntx_builder.add_recipient(address.script_pubkey(), send_amount);\n\nlet mut psbt = tx_builder.finish()?;\nlet finalized = wallet.sign(&amp;mut psbt, SignOptions::default())?;\nassert!(finalized);\n\nlet tx = psbt.extract_tx()?;\nclient.broadcast(&amp;tx)?;\nprintln!(\"Tx broadcasted! Txid: {}\", tx.compute_txid());\n</code></pre> <p>Again we can view the transaction in the Mutinynet explorer or re-run the <code>full-wallet</code> example to see that our wallet has less funds.</p>"},{"location":"cookbook/quickstart/","title":"Quick Start Example","text":"<p>This page provides an overview of how BDK can be leveraged to create and sync a wallet using an Esplora client. You can find working code examples of this workflow in three programming languages: Rust, Swift, and Kotlin.</p> <p>Tip</p> <p>This page is up-to-date with version <code>1.0.0-beta.5</code> of <code>bdk_wallet</code>.</p>"},{"location":"cookbook/quickstart/#create-a-new-project","title":"Create a new project","text":"RustSwiftKotlin <pre><code>cargo init quickstart\ncd quickstart\n</code></pre> <p>Create a new Swift project in Xcode.</p> <p>Create a new Kotlin project.</p>"},{"location":"cookbook/quickstart/#add-required-dependencies","title":"Add required dependencies","text":"RustSwiftKotlin Cargo.toml<pre><code>[package]\nname = \"quickstart\"\nversion = \"0.1.0\"\nedition = \"2021\"\n\n[dependencies]\nbdk_wallet = { version = \"=1.0.0-beta.5\" }\nbdk_esplora = { version = \"=0.19.0\", features = [\"blocking\"] }\n</code></pre> <ol> <li>From the Xcode File menu, select Add Package Dependencies...</li> <li>Enter <code>https://github.com/bitcoindevkit/bdk-swift</code> into the package repository URL text field</li> </ol> build.gradle<pre><code>repositories {\n    mavenCentral()\n}\n\ndependencies {\n    // for jvm\n    implementation 'org.bitcoindevkit:bdk-jvm:&lt;version&gt;'\n    // OR for android\n    implementation 'org.bitcoindevkit:bdk-android:&lt;version&gt;'\n}\n</code></pre>"},{"location":"cookbook/quickstart/#create-a-wallet-sync-it-and-display-the-balance","title":"Create a wallet, sync it and display the balance","text":"<p>We'll give a breakdown of the key pieces of this code in the next section.</p> RustSwiftKotlin examples/rust/quickstart/src/main.rs<pre><code>use bdk_wallet::AddressInfo;\nuse bdk_wallet::KeychainKind;\nuse bdk_wallet::bitcoin::Network;\nuse bdk_wallet::Wallet;\nuse bdk_esplora::EsploraExt;\nuse bdk_esplora::esplora_client::Builder;\nuse bdk_esplora::esplora_client;\nuse bdk_wallet::chain::spk_client::{FullScanRequestBuilder, FullScanResult};\n\nconst STOP_GAP: usize = 50;\nconst PARALLEL_REQUESTS: usize = 1;\n\nfn main() -&gt; () {\n\n    let descriptor: &amp;str = \"tr([12071a7c/86'/1'/0']tpubDCaLkqfh67Qr7ZuRrUNrCYQ54sMjHfsJ4yQSGb3aBr1yqt3yXpamRBUwnGSnyNnxQYu7rqeBiPfw3mjBcFNX4ky2vhjj9bDrGstkfUbLB9T/0/*)#z3x5097m\";\n    let change_descriptor: &amp;str = \"tr([12071a7c/86'/1'/0']tpubDCaLkqfh67Qr7ZuRrUNrCYQ54sMjHfsJ4yQSGb3aBr1yqt3yXpamRBUwnGSnyNnxQYu7rqeBiPfw3mjBcFNX4ky2vhjj9bDrGstkfUbLB9T/1/*)#n9r4jswr\";\n\n    // Create the wallet\n    let mut wallet: Wallet = Wallet::create(descriptor, change_descriptor)\n        .network(Network::Signet)\n        .create_wallet_no_persist()\n        .unwrap();\n\n    // Sync the wallet\n    let client: esplora_client::BlockingClient = Builder::new(\"https://mutinynet.com/api\").build_blocking();\n\n    println!(\"Syncing wallet...\");\n    let full_scan_request: FullScanRequestBuilder&lt;KeychainKind&gt; = wallet.start_full_scan();\n    let update: FullScanResult&lt;KeychainKind&gt; = client.full_scan(full_scan_request, STOP_GAP, PARALLEL_REQUESTS).unwrap();\n    // Apply the update from the full scan to the wallet\n    wallet.apply_update(update).unwrap();\n\n    let balance = wallet.balance();\n    println!(\"Wallet balance: {} sat\", balance.total().to_sat());\n\n    // Reveal a new address from your external keychain\n    let address: AddressInfo = wallet.reveal_next_address(KeychainKind::External);\n    println!(\"Generated address {} at index {}\", address.address, address.index);\n\n}\n</code></pre> examples/swift/quickstart/main.swift<pre><code>let descriptor = \"tr([12071a7c/86'/1'/0']tpubDCaLkqfh67Qr7ZuRrUNrCYQ54sMjHfsJ4yQSGb3aBr1yqt3yXpamRBUwnGSnyNnxQYu7rqeBiPfw3mjBcFNX4ky2vhjj9bDrGstkfUbLB9T/0/*)#z3x5097m\"\nlet changeDescriptor = \"tr([12071a7c/86'/1'/0']tpubDCaLkqfh67Qr7ZuRrUNrCYQ54sMjHfsJ4yQSGb3aBr1yqt3yXpamRBUwnGSnyNnxQYu7rqeBiPfw3mjBcFNX4ky2vhjj9bDrGstkfUbLB9T/1/*)#n9r4jswr\"\n\nlet wallet = try Wallet(\n    descriptor: descriptor, \n    changeDescriptor: changeDescriptor, \n    network: Network.signet\n)\n\nlet addressInfo = wallet.revealNextAddress(keychain: .external)\nprint(\"Generated address \\(addressInfo.address) at index \\(addressInfo.index)\")\n\nlet esploraClient = EsploraClient(url: \"https://mutinynet.com/api\")\n\nlet syncRequest = wallet.startSyncWithRevealedSpks()\nlet update = try esploraClient.sync(\n    syncRequest: syncRequest,\n    parallelRequests: UInt64(5)\n)\ntry wallet.applyUpdate(update: update)\nlet balance = wallet.balance()\nprint(\"Wallet balance: \\(balance.total) sat\")\n</code></pre> examples/kotlin/quickstart/main.kt<pre><code>val descriptor = \"tr([12071a7c/86'/1'/0']tpubDCaLkqfh67Qr7ZuRrUNrCYQ54sMjHfsJ4yQSGb3aBr1yqt3yXpamRBUwnGSnyNnxQYu7rqeBiPfw3mjBcFNX4ky2vhjj9bDrGstkfUbLB9T/0/*)#z3x5097m\"\nval changeDescriptor = \"tr([12071a7c/86'/1'/0']tpubDCaLkqfh67Qr7ZuRrUNrCYQ54sMjHfsJ4yQSGb3aBr1yqt3yXpamRBUwnGSnyNnxQYu7rqeBiPfw3mjBcFNX4ky2vhjj9bDrGstkfUbLB9T/1/*)#n9r4jswr\"\n\nval wallet = Wallet(\n  descriptor, \n  changeDescriptor, \n  Network.SIGNET\n)\n\nval addressInfo = wallet.revealNextAddress(KeychainKind.EXTERNAL)\nprintln(\"Generated address ${addressInfo.address} at index ${addressInfo.index}\")\n\nval esploraClient: EsploraClient = EsploraClient(\"https://mutinynet.com/api\")\n\nval syncRequest = wallet.startSyncWithRevealedSpks()\nval update = try esploraClient.sync(\n    syncRequest,\n    5uL\n)\nwallet.applyUpdate(update)\nval balance = wallet.balance()\nprintln(\"Wallet balance: ${balance.total()} sat\")\n</code></pre>"},{"location":"cookbook/quickstart/#build-and-run","title":"Build and run:","text":"<p>The wallet will take a few seconds to sync, then you should see the wallet balance printed in the terminal.</p> RustSwiftKotlin <pre><code>cargo build\ncargo run\n</code></pre> <p>Run the project in Xcode.</p> <p>Run the project in your IDE.</p>"},{"location":"cookbook/quickstart/#lets-take-a-closer-look","title":"Let's take a closer look","text":""},{"location":"cookbook/quickstart/#descriptors","title":"Descriptors","text":"<p>First we need some descriptors to instantiate our wallet. In this example we use public key descriptors to simply display the balance of a wallet. To sign transactions you will need to use a wallet that is instantiated with private key descriptors. Refer to the Creating Descriptors page for information on how to generate your own private descriptors.</p> RustSwiftKotlin <pre><code>let descriptor: &amp;str = \"tr([12071a7c/86'/1'/0']tpubDCaLkqfh67Qr7ZuRrUNrCYQ54sMjHfsJ4yQSGb3aBr1yqt3yXpamRBUwnGSnyNnxQYu7rqeBiPfw3mjBcFNX4ky2vhjj9bDrGstkfUbLB9T/0/*)#z3x5097m\";\nlet change_descriptor: &amp;str = \"tr([12071a7c/86'/1'/0']tpubDCaLkqfh67Qr7ZuRrUNrCYQ54sMjHfsJ4yQSGb3aBr1yqt3yXpamRBUwnGSnyNnxQYu7rqeBiPfw3mjBcFNX4ky2vhjj9bDrGstkfUbLB9T/1/*)#n9r4jswr\";\n</code></pre> <pre><code>let descriptor = \"tr([12071a7c/86'/1'/0']tpubDCaLkqfh67Qr7ZuRrUNrCYQ54sMjHfsJ4yQSGb3aBr1yqt3yXpamRBUwnGSnyNnxQYu7rqeBiPfw3mjBcFNX4ky2vhjj9bDrGstkfUbLB9T/0/*)#z3x5097m\"\nlet changeDescriptor = \"tr([12071a7c/86'/1'/0']tpubDCaLkqfh67Qr7ZuRrUNrCYQ54sMjHfsJ4yQSGb3aBr1yqt3yXpamRBUwnGSnyNnxQYu7rqeBiPfw3mjBcFNX4ky2vhjj9bDrGstkfUbLB9T/1/*)#n9r4jswr\"\n</code></pre> <pre><code>val descriptor = \"tr([12071a7c/86'/1'/0']tpubDCaLkqfh67Qr7ZuRrUNrCYQ54sMjHfsJ4yQSGb3aBr1yqt3yXpamRBUwnGSnyNnxQYu7rqeBiPfw3mjBcFNX4ky2vhjj9bDrGstkfUbLB9T/0/*)#z3x5097m\"\nval changeDescriptor = \"tr([12071a7c/86'/1'/0']tpubDCaLkqfh67Qr7ZuRrUNrCYQ54sMjHfsJ4yQSGb3aBr1yqt3yXpamRBUwnGSnyNnxQYu7rqeBiPfw3mjBcFNX4ky2vhjj9bDrGstkfUbLB9T/1/*)#n9r4jswr\"\n</code></pre> <p>These are taproot <code>tr()</code> descriptors using public keys on testnet (or signet) <code>tpub</code> as described in BIP86. The <code>descriptor</code> is an HD wallet with a path for generating addresses to give out externally for payment. We also have a second <code>change_descriptor</code> that we can use to generate addresses to pay ourseves change when sending payments (remeber that UTXOs must be spent if full, so you often want to make change).</p>"},{"location":"cookbook/quickstart/#blockchain-client-and-network","title":"Blockchain Client and Network","text":"<p>This example is using an Esplora client on the Mutinynet Signet network.</p> RustSwiftKotlin <pre><code>let client: esplora_client::BlockingClient = Builder::new(\"https://mutinynet.com/api\").build_blocking();\n</code></pre> <pre><code>let esploraClient = EsploraClient(url: \"https://mutinynet.com/api\")\n</code></pre> <pre><code>val esploraClient: EsploraClient = EsploraClient(\"https://mutinynet.com/api\")\n</code></pre> <p>Other options for blockchain clients include running an Electrum light wallet or using RPC on a bitcoind fullnode. We are using Esplora in this example.</p> <p>This example also used the Signet network. You may alternatively want to run this example wallet using a locally hosted Regtest network. The details of how to set that up are beyond the scope of this example.</p>"},{"location":"cookbook/quickstart/#scan","title":"Scan","text":"<p>Once we have our wallet setup and connected to the network, we scan the network to detect UTXOs relevant to our wallet.</p> RustSwiftKotlin <pre><code>let full_scan_request: FullScanRequestBuilder&lt;KeychainKind&gt; = wallet.start_full_scan();\nlet update: FullScanResult&lt;KeychainKind&gt; = client.full_scan(full_scan_request, STOP_GAP, PARALLEL_REQUESTS).unwrap();\n// Apply the update from the full scan to the wallet\nwallet.apply_update(update).unwrap();\n\nlet balance = wallet.balance();\nprintln!(\"Wallet balance: {} sat\", balance.total().to_sat());\n</code></pre> <pre><code>let syncRequest = wallet.startSyncWithRevealedSpks()\nlet update = try esploraClient.sync(\n    syncRequest: syncRequest,\n    parallelRequests: UInt64(5)\n)\ntry wallet.applyUpdate(update: update)\nlet balance = wallet.balance()\nprint(\"Wallet balance: \\(balance.total) sat\")\n</code></pre> <pre><code>val syncRequest = wallet.startSyncWithRevealedSpks()\nval update = try esploraClient.sync(\n    syncRequest,\n    5uL\n)\nwallet.applyUpdate(update)\nval balance = wallet.balance()\nprintln(\"Wallet balance: ${balance.total()} sat\")\n</code></pre> <p>This scanning process is detailed on the Full Scan vs Sync page. The scanning process checks child pubkeys for the descriptors specified in the wallet to detect UTXOs that are relevant to the wallet. That data is then applied to the wallet.</p>"},{"location":"cookbook/quickstart/#display-wallet-balance","title":"Display Wallet Balance","text":"<p>Finally we can print the <code>wallet.balance()</code> to see how many sats we have available based on the information gathered in the scanning process.</p>"},{"location":"cookbook/keys-descriptors/descriptors/","title":"Creating Keys and Descriptors","text":"<p>BDK is a descriptor-first library. This page explores how to build them and how they interact with other standards like BIP-39 recovery phrases.</p> <p>Danger</p> <p>The keys and descriptors used in The Book of BDK are for illustration purposes only; UNDER NO CIRCUMSTANCES should any of the keys or descriptors containing private data be used for real money. Entropy generation should be carried out in a secure environment using cryptographically secure random number generators (CSPRNG).</p>"},{"location":"cookbook/keys-descriptors/descriptors/#using-descriptor-templates","title":"Using descriptor templates","text":"<p>BDK offers utility constructs called descriptor templates, which allow you to build descriptors for the four most common script types (BIP 44/49/84/86) with minimal effort.</p> <p>The following will build and print the full string representation of taproot (BIP-86) internal and external descriptors. We print both the public key descriptors (for HD wallet address generation only) and private key descriptors (for full wallet functionality including transaction signing).</p> <pre><code>use bdk_wallet::bitcoin::bip32::Xpriv;\nuse bdk_wallet::bitcoin::Network;\nuse bdk_wallet::KeychainKind;\nuse bdk_wallet::template::{Bip86, DescriptorTemplate};\nuse bdk_wallet::bitcoin::secp256k1::rand;\nuse bdk_wallet::bitcoin::secp256k1::rand::RngCore;\n\nfn main() -&gt; () {\n    // --8&lt;-- [start:main]\n    let mut seed: [u8; 32] = [0u8; 32];\n    rand::thread_rng().fill_bytes(&amp;mut seed);\n\n    let network: Network = Network::Signet;\n    let xprv: Xpriv = Xpriv::new_master(network, &amp;seed).unwrap();\n    println!(\"Generated Master Private Key:\\n{}\\nWarning: be very careful with private keys when using MainNet! We are logging these values for convenience only because this is an example on SigNet.\\n\", xprv);\n\n    let (descriptor, key_map, _) = Bip86(xprv, KeychainKind::External)\n        .build(Network::Signet)\n        .expect(\"Failed to build external descriptor\");\n\n    let (change_descriptor, change_key_map, _) = Bip86(xprv, KeychainKind::Internal)\n        .build(Network::Signet)\n        .expect(\"Failed to build internal descriptor\");\n\n    let descriptor_string_priv = descriptor.to_string_with_secret(&amp;key_map);\n    let change_descriptor_string_priv = descriptor.to_string_with_secret(&amp;change_key_map);\n    // --8&lt;-- [end:main]\n\n    println!(\n        \"----------------  Descriptors  ------------------------------\\nPrivate Key, External:\\n{:?}\\nPrivate Key, Internal:\\n{:?}\\nPublic Key, External:\\n{:?}\\nPublic Key, Internal:\\n{:?}\\n\",\n        descriptor_string_priv, // privkey\n        change_descriptor_string_priv,\n        descriptor.to_string(), // pubkey\n        change_descriptor.to_string()\n    );\n}\n</code></pre>"},{"location":"cookbook/keys-descriptors/seed-phrase/","title":"Recover Descriptors from Seeds","text":"<p>BDK wallets require the use of descriptors, but recovery phrases (also called seed phrases) are a common and popular backup solution. Creating descriptors from a recovery phrase is a common workflow and BDK makes this easy with its descriptor templates, which are offered for common descriptors (BIP 44/49/84/86).</p> <p>Feature Flags</p> <p>The current example requires the feature <code>keys-bip39</code> for <code>bdk_wallet</code>. You can add it with:</p> <pre><code>cargo add bdk_wallet --features=\"keys-bip39\"\n</code></pre>"},{"location":"cookbook/keys-descriptors/seed-phrase/#example","title":"Example","text":"<pre><code>use bdk_wallet::bitcoin::bip32::Xpriv;\nuse bdk_wallet::bitcoin::Network;\nuse bdk_wallet::KeychainKind;\nuse bdk_wallet::template::{Bip86, DescriptorTemplate};\nuse bdk_wallet::keys::bip39::Mnemonic;\n\nconst RECOVERY_PHRASE: &amp;str = \"[your 12 word seed phrase here ...]\";\n// const RECOVERY_PHRASE: &amp;str = \"holiday marble tide globe license stumble rescue antenna monitor sea half sauce\"; // example\n\nfn main() -&gt; () {\n    let mnemonic = Mnemonic::parse(RECOVERY_PHRASE).expect(\"Invalid seed! Be sure to replace the value of RECOVERY_PHRASE with your own 12 word seed phrase.\");\n    let seed = mnemonic.to_seed(\"\");\n    let xprv: Xpriv =\n        Xpriv::new_master(Network::Signet, &amp;seed).expect(\"Failed to create master key\");\n    println!(\"Generated Master Private Key:\\n{}\\nWarning: be very careful with seeds and private keys when using MainNet! We are logging these values for convenience only because this is an example on SigNet.\\n\", xprv);\n\n    let (descriptor, key_map, _) = Bip86(xprv, KeychainKind::External)\n        .build(Network::Signet)\n        .expect(\"Failed to build external descriptor\");\n\n    let (change_descriptor, change_key_map, _) = Bip86(xprv, KeychainKind::Internal)\n        .build(Network::Signet)\n        .expect(\"Failed to build internal descriptor\");\n\n    println!(\n        \"----------------  Descriptors  ------------------------------\\nPrivate Key, External:\\n{:?}\\nPrivate Key, Internal:\\n{:?}\\nPublic Key, External:\\n{:?}\\nPublic Key, Internal:\\n{:?}\\n\",\n        descriptor.to_string_with_secret(&amp;key_map), // privkey\n        change_descriptor.to_string_with_secret(&amp;change_key_map),\n        descriptor.to_string(), // pubkey\n        change_descriptor.to_string()\n    );\n}\n</code></pre>"},{"location":"cookbook/persistence/flat-file/","title":"Flat File Persistence","text":"<p>TODO</p>"},{"location":"cookbook/persistence/memory/","title":"In-Memory Wallet","text":"<p>The simplest wallet is one that does not have any persistence. All information about the wallet is held in memory, and will be destroyed upon termination of the process.</p> <p>In-memory implies that the addresses the wallet has revealed, the syncing that has been performed including data on the transaction graph will not persist when the wallet is destroyed, and related operations will need to be performed again.</p> <p>In general, this means performing a <code>full_scan()</code> when starting the wallet, because it has no knowledge of which addresses were given out and which scripts still have balances.</p> <p>See our page on the difference between the full scan and sync operations for more on this topic.</p>"},{"location":"cookbook/persistence/memory/#example","title":"Example","text":"<p>The in-memory wallet does not require any additional dependencies beyond the <code>bdk_wallet</code> dependency:</p> <pre><code>[dependencies]\nbdk_wallet = { version = \"=1.0.0-beta.1\" }\n</code></pre> <p>To create an in-memory wallet, simply call <code>create_wallet_no_persist()</code> on the <code>Wallet</code> builder:</p> <pre><code>let mut wallet = Wallet::create(EXTERNAL_DESCRIPTOR, INTERNAL_DESCRIPTOR)\n    .network(Network::Signet)\n    .create_wallet_no_persist()\n    .expect(\"valid wallet\");\n</code></pre> <p></p>"},{"location":"cookbook/persistence/sqlite/","title":"SQLite Database","text":"<p>The SQLite persistence is a great default for many use cases, and is a good place to start if you're not sure which persistence to choose from.</p> <p>By default when using the <code>bdk_wallet</code> library, all information about the wallet is held in memory, and will be destroyed upon termination of the process unless saved to persistence. </p> <p>When information important to the wallet is added to it, the wallet will add it to its staged area. Whenever you want to save this information to persistence, call the <code>Wallet.persist(&amp;mut db)</code>.</p> <p>The operations that affect the wallet and produce a changeset are things like:</p> <ul> <li>Revealing new addresses</li> <li>Sync operations that pick up new UTXOs</li> </ul> <p>Once those things are persisted, upon loading of the database changeset the wallet would be able to rehydrate its TxGraph, which includes UTXOs, transaction history, and latest blocks known to the wallet. This means that a wallet that's been loaded from such a persistence will not require a Full Scan but rather simply a Sync.</p> <p>See our page on the difference between the full scan and sync operations for more on this topic.</p>"},{"location":"cookbook/persistence/sqlite/#example","title":"Example","text":"<p>The sqlite wallet does not require any additional dependencies above the <code>bdk_wallet</code> dependency:</p> <pre><code>[dependencies]\nbdk_wallet = { version = \"=1.0.0-beta.1\", features = [\"rusqlite\"] }\n</code></pre> <p>To create a sqlite-based persisted wallet, simply call the <code>create_wallet()</code> with a valid db connection on the wallet builder:</p> <pre><code>use bdk_wallet::rusqlite::Connection;\n\nlet mut conn = Connection::open(file_path)?;\nlet wallet = Wallet::create(EXTERNAL_DESCRIPTOR, INTERNAL_DESCRIPTOR)\n    .network(Network::Signet)\n    .create_wallet(&amp;mut conn)\n    .expect(\"valid wallet and db connection\");\n</code></pre> <p>After performing an operation that returns data that should be persisted, use the <code>persist()</code> method on the wallet:</p> <pre><code>let address = wallet.next_unused_address(KeychainKind::External);\nwallet.persist(&amp;mut conn)?;\n</code></pre> <p></p>"},{"location":"cookbook/syncing/electrum/","title":"Sync a Wallet with Electrum","text":"<p>Tip</p> <p>This page is up-to-date with version <code>1.0.0-alpha.13</code> of bdk.</p>"},{"location":"cookbook/syncing/electrum/#add-required-bdk-dependencies-to-your-cargotoml-file","title":"Add required bdk dependencies to your <code>Cargo.toml</code> file","text":"<pre><code>[dependencies]\nbdk_wallet = { version = \"=1.0.0-beta.1\" }\nbdk_electrum = { version = \"=0.16.0\" }\n</code></pre>"},{"location":"cookbook/syncing/electrum/#create-and-sync-the-wallet","title":"Create and sync the wallet","text":"<pre><code>use bdk_wallet::AddressInfo;\nuse bdk_wallet::KeychainKind;\nuse bdk_wallet::bitcoin::Network;\nuse bdk_wallet::Wallet;\nuse bdk_electrum::{BdkElectrumClient, electrum_client};\nuse bdk_electrum::electrum_client::Client;\n\nconst STOP_GAP: usize = 50;\nconst BATCH_SIZE: usize = 5;\nconst EXTERNAL_DESCRIPTOR: &amp;str = \"tr(tprv8ZgxMBicQKsPewab4KfjNu6p9Q5XAPokRpK9zrPGoJS7H6CqnxuKJX6zPBDj2Q43tfmVBRTpQMBSg8AhqBDdNEsBC14kMXiZj2tPWv5wHAE/86'/1'/0'/0/*)#30pfz5ly\";\nconst INTERNAL_DESCRIPTOR: &amp;str = \"tr(tprv8ZgxMBicQKsPewab4KfjNu6p9Q5XAPokRpK9zrPGoJS7H6CqnxuKJX6zPBDj2Q43tfmVBRTpQMBSg8AhqBDdNEsBC14kMXiZj2tPWv5wHAE/86'/1'/0'/1/*)\";\n\nfn main() -&gt; () {\n    let mut wallet: Wallet = Wallet::create(EXTERNAL_DESCRIPTOR, INTERNAL_DESCRIPTOR)\n        .network(Network::Signet)\n        .create_wallet_no_persist()\n        .unwrap();\n\n    let address: AddressInfo = wallet.reveal_next_address(KeychainKind::External);\n    println!(\"Generated address {} at index {}\", address.address, address.index);\n\n    // Create the Electrum client\n    let client: BdkElectrumClient&lt;Client&gt; = BdkElectrumClient::new(\n        electrum_client::Client::new(\"ssl://mempool.space:60602\").unwrap()\n    );\n\n    // Perform the initial full scan on the wallet\n    let full_scan_request = wallet.start_full_scan();\n    let mut update = client.full_scan(full_scan_request, STOP_GAP, BATCH_SIZE, true).unwrap();\n\n    let now = std::time::UNIX_EPOCH.elapsed().unwrap().as_secs();\n    let _ = update.graph_update.update_last_seen_unconfirmed(now);\n\n    wallet.apply_update(update).unwrap();\n    let balance = wallet.balance();\n    println!(\"Wallet balance: {} sat\", balance.total().to_sat());\n}\n</code></pre>"},{"location":"cookbook/syncing/esplora/","title":"Sync a Wallet with Esplora","text":"<p>Tip</p> <p>This page is up-to-date with version <code>1.0.0-alpha.13</code> of bdk.</p>"},{"location":"cookbook/syncing/esplora/#add-required-bdk-dependencies-to-your-cargotoml-file","title":"Add required bdk dependencies to your Cargo.toml file","text":"<pre><code>[dependencies]\nbdk = { version = \"=1.0.0-beta.1\" }\nbdk_esplora = { version = \"=0.16.0\", features = [\"blocking\"] }\n</code></pre>"},{"location":"cookbook/syncing/esplora/#create-and-sync-the-wallet","title":"Create and sync the wallet","text":"<pre><code>use bdk_wallet::AddressInfo;\nuse bdk_wallet::KeychainKind;\nuse bdk_wallet::bitcoin::Network;\nuse bdk_wallet::Wallet;\nuse bdk_esplora::EsploraExt;\nuse bdk_esplora::esplora_client::Builder;\n\nconst STOP_GAP: usize = 50;\nconst PARALLEL_REQUESTS: usize = 1;\nconst EXTERNAL_DESCRIPTOR: &amp;str = \"tr(tprv8ZgxMBicQKsPdrjwWCyXqqJ4YqcyG4DmKtjjsRt29v1PtD3r3PuFJAjWytzcvSTKnZAGAkPSmnrdnuHWxCAwy3i1iPhrtKAfXRH7dVCNGp6/86'/1'/0'/0/*)#g9xn7wf9\";\nconst INTERNAL_DESCRIPTOR: &amp;str = \"tr(tprv8ZgxMBicQKsPdrjwWCyXqqJ4YqcyG4DmKtjjsRt29v1PtD3r3PuFJAjWytzcvSTKnZAGAkPSmnrdnuHWxCAwy3i1iPhrtKAfXRH7dVCNGp6/86'/1'/0'/1/*)#e3rjrmea\";\n\nfn main() -&gt; () {\n    let mut wallet: Wallet = Wallet::create(EXTERNAL_DESCRIPTOR, INTERNAL_DESCRIPTOR)\n        .network(Network::Signet)\n        .create_wallet_no_persist()\n        .unwrap();\n\n    let address: AddressInfo = wallet.reveal_next_address(KeychainKind::External);\n    println!(\"Generated address {} at index {}\", address.address, address.index);\n\n    // Create the Esplora client\n    let client = Builder::new(\"http://signet.bitcoindevkit.net\").build_blocking();\n\n    // Perform the initial full scan on the wallet\n    let full_scan_request = wallet.start_full_scan();\n    let mut update = client.full_scan(full_scan_request, STOP_GAP, PARALLEL_REQUESTS).unwrap();\n    let now = std::time::UNIX_EPOCH.elapsed().unwrap().as_secs();\n    let _ = update.graph_update.update_last_seen_unconfirmed(now);\n    wallet.apply_update(update).unwrap();\n\n    let balance = wallet.balance();\n    println!(\"Wallet balance: {} sat\", balance.total().to_sat());\n}\n</code></pre>"},{"location":"cookbook/syncing/full-scan-vs-sync/","title":"Full Scan vs Sync","text":"<p>The BDK libraries rely on two syncing concepts we call Full Scan and Sync. This page explains the difference between the two and recommendations on when to use each.</p>"},{"location":"cookbook/syncing/full-scan-vs-sync/#full-scan","title":"Full Scan","text":"<p>A full scan is an operation that aims to build a complete picture of a wallet's UTXOs from scratch, with no prior data or knowledge about the wallet required. It involves querying the blockchain data client for ScriptPubKeys that the wallet owns, typically at a number of indices on two keychains, an external keychain and an internal one (often called a change keychain). Because the wallet doesn't know which scripts/addresses have been given out and potentially have funds associated with them, it needs to query the blockchain client for a group of addresses, see if any of those have balances, and keep asking for more until a number of addresses in a row for each keychain are unused (the exact number is configurable and is what's typically known as a stop gap). The operation also returns a new chain tip the wallet uses to update its <code>LocalChain</code>.</p> <p>A full scan is only needed in cases where the wallet is unknown and is not loaded from persistence. In almost all other instances, a sync should be performed.</p>"},{"location":"cookbook/syncing/full-scan-vs-sync/#sync","title":"Sync","text":"<p>A sync is a related operation which can be thought of as \"catching up\" on the latest things that have happened on the chain since the last full scan or sync. A sync only makes sense if the list of addresses given out is known, and will query the blockchain data client for those scripts only. It also returns a new chain tip the wallet uses to update its <code>LocalChain</code>.</p> <p>A sync is a smaller and more optimal operation than a full scan, and should be used in almost all cases after an initial full scan has been performed.</p>"},{"location":"cookbook/syncing/full-scan-vs-sync/#additional-considerations","title":"Additional Considerations","text":"<p>The following heuristics work well for most standard wallets:</p> <ol> <li>If you are recovering a wallet which currently holds or has ever held a balance or are creating a wallet from scratch, your first syncing operation should be a full scan. This will allow the wallet to discover which scripts have been used and create an accurate overall balance. All other syncing operations should be sync.</li> <li>If you are loading a wallet from persistence for which a full scan has already been performed and related data has been persisted, your syncing operations should be sync.</li> <li>If you are operating on a wallet which is shared with other entities which might reveal addresses, your local wallet and its <code>TxGraph</code> will not know about these revealed scripts. In this case, and if you suspect addresses might have been revealed, you should perform a full scan.</li> </ol>"},{"location":"cookbook/syncing/full-scan-vs-sync/#examples","title":"Examples","text":"<p>The workflow for a full scan or sync consists of a 3-step process:</p> <ol> <li>Ask the wallet for the data structure required.</li> <li>Pass it to your blockchain client and request a full scan or sync.</li> <li>The client returns an update, which you then apply to the wallet.</li> </ol> <p>This workflow ensures that the wallet structure is not blocked while the syncing operation is performed.</p>"},{"location":"cookbook/syncing/full-scan-vs-sync/#full-scan-with-esplora","title":"Full Scan With Esplora","text":"<pre><code>// Create the Esplora client\nlet client: esplora_client::BlockingClient = Builder::new(\"http://signet.bitcoindevkit.net\").build_blocking();\n\n// Full scan the wallet\nlet full_scan_request: FullScanRequest&lt;KeychainKind&gt; = wallet.start_full_scan()\nlet update: FullScanResult&lt;KeychainKind&gt; = client.full_scan(full_scan_request, STOP_GAP, PARALLEL_REQUESTS)?;\n\n// Apply the update to the wallet\nwallet.apply_update(update)?;\n</code></pre>"},{"location":"cookbook/syncing/full-scan-vs-sync/#sync-with-esplora","title":"Sync With Esplora","text":"<pre><code>// Create the Esplora client\nlet client: esplora_client::BlockingClient = Builder::new(\"http://signet.bitcoindevkit.net\").build_blocking();\n\n// Sync the wallet\nlet sync_request: SyncRequest = wallet.start_sync_with_revealed_spks()\nlet update: SyncResult = client.sync(sync_request, PARALLEL_REQUESTS)?;\n\n// Apply the update to the wallet\nwallet.apply_update(update)?;\n</code></pre>"},{"location":"cookbook/syncing/rpc/","title":"Sync a Wallet with Bitcoin Core RPC","text":"<p>Tip</p> <p>This page is up-to-date with version <code>1.0.0-beta.1</code> of bdk.</p>"},{"location":"cookbook/syncing/rpc/#1-start-a-regtest-bitcoin-daemon","title":"1. Start a regtest bitcoin daemon","text":"<p>For this example you'll need to run a bitcoin core daemon locally in regtest mode. Here are some of the commands you'll need: <pre><code># In a shell dedicated to the bitcoin daemon \nbitcoind --chain=regtest\n\n# In a new shell dedicated to the bitcoin-cli\nbitcoin-cli --chain=regtest getblockchaininfo\n\nbitcoin-cli --chain=regtest createwallet mywallet\nbitcoin-cli --chain=regtest loadwallet mywallet\nbitcoin-cli --chain=regtest getnewaddress\n\n# Mine 101 blocks\nbitcoin-cli --chain=regtest generatetoaddress 101 &lt;address&gt;\n\n# Send to address\nbitcoin-cli --chain=regtest sendtoaddress &lt;address&gt; &lt;amount&gt;\n</code></pre></p>"},{"location":"cookbook/syncing/rpc/#2-create-a-new-rust-project","title":"2. Create a new Rust project","text":"<pre><code>cargo init rpcexample\ncd rpcexample\n</code></pre>"},{"location":"cookbook/syncing/rpc/#3-add-required-bdk-dependencies-to-your-cargotoml-file","title":"3. Add required bdk dependencies to your <code>Cargo.toml</code> file","text":"<pre><code>[package]\nname = \"rpcexample\"\nversion = \"0.1.0\"\nedition = \"2021\"\n\n[dependencies]\nbdk = { version = \"=1.0.0-beta.1\" }\nbdk_bitcoind_rpc = {  version = \"0.13.0\" }\n</code></pre>"},{"location":"cookbook/syncing/rpc/#4-create-your-descriptors","title":"4. Create your descriptors","text":"<p>Refer to the Working with Descriptors page for information on how to generate descriptors. This page will assume you are working on Regtest with the following BIP86 descriptors: <pre><code>const EXTERNAL_DESCRIPTOR: &amp;str = \"tr(tprv8ZgxMBicQKsPdrjwWCyXqqJ4YqcyG4DmKtjjsRt29v1PtD3r3PuFJAjWytzcvSTKnZAGAkPSmnrdnuHWxCAwy3i1iPhrtKAfXRH7dVCNGp6/86'/1'/0'/0/*)#g9xn7wf9\";\nconst INTERNAL_DESCRIPTOR: &amp;str = \"tr(tprv8ZgxMBicQKsPdrjwWCyXqqJ4YqcyG4DmKtjjsRt29v1PtD3r3PuFJAjWytzcvSTKnZAGAkPSmnrdnuHWxCAwy3i1iPhrtKAfXRH7dVCNGp6/86'/1'/0'/1/*)#e3rjrmea\";\n</code></pre></p>"},{"location":"cookbook/syncing/rpc/#5-create-and-sync-wallet","title":"5. Create and sync wallet","text":"<pre><code>use bdk_bitcoind_rpc::bitcoincore_rpc::{Auth, Client, RpcApi};\nuse bdk_bitcoind_rpc::Emitter;\nuse bdk_wallet::bitcoin::{Network, Transaction};\nuse bdk_wallet::chain::local_chain::CheckPoint;\nuse bdk_wallet::{AddressInfo, Balance, KeychainKind, Wallet};\n\nconst COOKIE_FILE_PATH: &amp;str = \"&lt;path_to_your_regtest_bitcoin_core_data_dir&gt;/.cookie\";\nconst EXTERNAL_DESCRIPTOR: &amp;str = \"tr(tprv8ZgxMBicQKsPdrjwWCyXqqJ4YqcyG4DmKtjjsRt29v1PtD3r3PuFJAjWytzcvSTKnZAGAkPSmnrdnuHWxCAwy3i1iPhrtKAfXRH7dVCNGp6/86'/1'/0'/0/*)#g9xn7wf9\";\nconst INTERNAL_DESCRIPTOR: &amp;str = \"tr(tprv8ZgxMBicQKsPdrjwWCyXqqJ4YqcyG4DmKtjjsRt29v1PtD3r3PuFJAjWytzcvSTKnZAGAkPSmnrdnuHWxCAwy3i1iPhrtKAfXRH7dVCNGp6/86'/1'/0'/1/*)#e3rjrmea\";\n\nfn main() -&gt; () {\n    let mut wallet: Wallet = Wallet::create(EXTERNAL_DESCRIPTOR, INTERNAL_DESCRIPTOR)\n        .network(Network::Regtest)\n        .create_wallet_no_persist()\n        .unwrap();\n\n    let balance: Balance = wallet.balance();\n    println!(\"Wallet balance before syncing: {}\", balance.total());\n\n    let address: AddressInfo = wallet.reveal_next_address(KeychainKind::External);\n    println!(\"Generated address {} at index {}\", address.address, address.index);\n\n    let rpc_client: Client = Client::new(\n        \"http://127.0.0.1:18443\",\n        // Auth::UserPass(\"__cookie__\".to_string(), \"cookievalue\".to_string())\n        Auth::CookieFile(COOKIE_FILE_PATH.into())\n    ).unwrap();\n\n    let blockchain_info = rpc_client.get_blockchain_info().unwrap();\n    println!(\n        \"\\nConnected to Bitcoin Core RPC.\\nChain: {}\\nLatest block: {} at height {}\\n\",\n        blockchain_info.chain, blockchain_info.best_block_hash, blockchain_info.blocks,\n    );\n\n    let wallet_tip: CheckPoint = wallet.latest_checkpoint();\n    println!(\n        \"Current wallet tip is: {} at height {}\",\n        &amp;wallet_tip.hash(),\n        &amp;wallet_tip.height()\n    );\n\n    let mut emitter = Emitter::new(&amp;rpc_client, wallet_tip.clone(), wallet_tip.height());\n\n    println!(\"Syncing blocks...\");\n    while let Some(block) = emitter.next_block().unwrap() {\n        // the `block` variable is of type `BlockEvent&lt;Block&gt;`\n        print!(\"{} \", block.block_height());\n\n        wallet\n            .apply_block_connected_to(&amp;block.block, block.block_height(), block.connected_to())\n            .unwrap();\n    }\n    println!();\n\n    println!(\"Syncing mempool...\");\n    let mempool_emissions: Vec&lt;(Transaction, u64)&gt; = emitter.mempool().unwrap();\n\n    wallet.apply_unconfirmed_txs(mempool_emissions.iter().map(|(tx, time)| (tx, *time)));\n\n    let balance: Balance = wallet.balance();\n    println!(\"Wallet balance after syncing: {}\", balance.total());\n}\n</code></pre> <p>Once you have synced the wallet once, mine a few new blocks using the bitcoin-cli and send coins to the address provided by the wallet and printed in the console. Upon running the example code again, your wallet will sync up the latest blocks and update its balance.</p>"},{"location":"cookbook/transactions/transaction-builder/","title":"Transaction Builder","text":"<p>The Transaction Builder provides a convenient way to construct bitcoin transactions by offering a builder-type API that helps developers manage the typical requirements for building transactions: recipients, fees, signatures, and a whole lot more.</p>"},{"location":"cookbook/transactions/transaction-builder/#features","title":"Features","text":"<ul> <li>Flexible Input and Output Selection: You can add or subtract inputs and outputs as needed.</li> <li>Fees: The builder calculates and adds fees automatically based on a specified fee rate or absolute target.</li> <li>Finalization: The builder helps finalize the transaction, ensuring signatures and other conditions are met.</li> </ul>"},{"location":"cookbook/transactions/transaction-builder/#usage","title":"Usage","text":"<p>To start building a new transaction, instantiate the <code>TxBuilder</code> type provided by BDK by calling the <code>Wallet::build_tx()</code> method. On this builder you chain various methods to add inputs, outputs, and configure other settings. Finally, call <code>TxBuilder::finish()</code> to get a PSBT ready for signing.</p> <pre><code>let psbt = wallet.build_tx()\n    .add_recipient(address.script_pubkey(), amount)\n    .finish()?;\n</code></pre>"},{"location":"cookbook/transactions/transaction-builder/#customizing-outputs","title":"Customizing Outputs","text":"<p>You can specify multiple recipients for the transaction, distributing funds across various addresses. The output is added as a script with an amount:</p> <pre><code>wallet.build_tx()\n    .add_recipient(to_address1.script_pubkey(), amount1)\n    .add_recipient(to_address2.script_pubkey(), amount2)\n</code></pre>"},{"location":"cookbook/transactions/transaction-builder/#choosing-inputs","title":"Choosing Inputs","text":"<p>You can manually select specific UTXOs, as well as request to not spend specific UTXOs:</p> <pre><code>wallet.build_tx()\n    .add_utxo(utxo1)?\n    .add_unspendable(utxo2)\n    .add_recipient(address.script_pubkey(), amount)\n</code></pre> <p>Combining the above with <code>TxBuilder::manually_selected_only</code> will ensure that the wallet only spends UTXOs specified by the <code>TxBuilder::add_utxo</code> method.</p> <p>Alternatively, let the wallet choose the inputs:</p> <pre><code>wallet.build_tx()\n    .add_recipient(address.script_pubkey(), amount)\n</code></pre>"},{"location":"cookbook/transactions/transaction-builder/#fee-management","title":"Fee Management","text":"<p>The builder allows you to define a fee rate or an absolute fee:</p> <pre><code>wallet.build_tx()\n    .fee_rate(FeeRate::from_sat_per_vb(4))\n    .fee_absolute(Amount::from_sat(600))\n</code></pre> <p>Note that if you set the fee using both the fee_absolute and the fee_rate method, the wallet will use method was called last, as the fee rate and the absolute fee amount are mutually exclusive.</p>"},{"location":"cookbook/transactions/transaction-builder/#spend-all-funds","title":"Spend all funds","text":"<p>The transaction builder has a convenience method that will spend all UTXOs available to it (while respecting the unspendable UTXOs if any). Simple use of this method will simply increase the size of your change output, but you can combine it with the <code>TxBuilder::drain_to</code> method to ensure all funds are sent to a specific address:</p> <pre><code>let psbt = wallet.build_tx()\n    .drain_wallet()\n    .drain_to(address.script_pubkey())\n</code></pre>"},{"location":"cookbook/transactions/transaction-builder/#set-the-nsequence-value","title":"Set the nSequence value","text":"<p>The <code>TxBuilder::set_exact_sequence</code> method allows users to set their nSequence value directly. This is also the way you would disable signaling for RBF, as the TxBuilder will by default enable it.</p> <pre><code>wallet.build_tx()\n    .add_recipient(address.script_pubkey(), amount)\n    .set_exact_sequence(sequence)\n</code></pre>"},{"location":"cookbook/transactions/transaction-builder/#finalizing-the-psbt","title":"Finalizing the PSBT","text":"<p>Once you\u2019ve added inputs, outputs, and calculated the fees, you can build the psbt using the <code>TxBuilder::finish</code> method.</p> <pre><code>let psbt = wallet.build_tx()\n    .finish()?;\n</code></pre> <p>The result is a PSBT ready to be signed and later on broadcast to the network.</p>"},{"location":"cookbook/transactions/transaction-builder/#signing-the-psbt-and-extrating-the-transaction","title":"Signing the PSBT and extrating the transaction","text":"<p>Sign the PSBT using the <code>Wallet::sign</code> method and extract the finalized transaction from it using the Psbt::extract_tx` method for a ready-to-be-broadcast transaction.</p> <pre><code>wallet.sign(&amp;mut psbt, SignOptions::default())?;\nlet tx = psbt.extract_tx()?;\n</code></pre>"},{"location":"getting-started/api-documentation/","title":"API Documentation","text":"<p>Our API documentation is available here:</p> <ul> <li>bdk_wallet</li> <li>bdk_chain</li> <li>bdk_file_store</li> <li>bdk_electrum</li> <li>bdk_esplora</li> <li>bdk_bitcoind_rpc</li> <li>bdk_hwi</li> <li>esplora-client</li> <li>electrum-client</li> </ul>"},{"location":"getting-started/build-a-wallet/","title":"I Want To Build A Wallet Using BDK","text":"<p>So you want to build a bitcoin wallet using BDK. Great! Here is the rough outline of what you need to do just that. A standard, simple example of a bitcoin wallet in BDK-land would require 3 core pillars:</p> <ol> <li>The <code>bdk_wallet</code> library, which will provide two core types: the <code>Wallet</code> and the <code>TxBuilder</code>. This library will handle all the domain logic related to keeping track of which UTXOs you own, what your total balance is, creating and signing transactions, etc.</li> <li>A blockchain client. Your wallet will need to keep track of blockchain data, like new transactions that have been added to the blockchain that impact your wallet, requesting these transactions to a Bitcoin Core node, an Electrum or Esplora server, etc.</li> <li>A persistence mechanism for saving wallet data between sessions (note that this is not actually required). Things like which addresses the wallet has revealed and what is the state of the blockchain on its last sync are things that are kept in persistence and can be loaded on startup.</li> </ol> The 3 core pieces of a BDK wallet."},{"location":"getting-started/getting-started/","title":"Getting Started","text":""},{"location":"getting-started/getting-started/#install-rust","title":"Install Rust","text":"<p>See the Rust Getting Started page to install the Rust development tools.</p>"},{"location":"getting-started/getting-started/#using-bdk-in-a-rust-project","title":"Using BDK in a Rust project","text":"<p>Follow these steps to use BDK in your own rust project with the <code>electrum</code> blockchain client.</p> <p>Tip</p> <p>For now, we suggest using the latest <code>master</code> branch versions of BDK crates. As an example, for BDK:</p> <pre><code>cargo add bdk\n</code></pre> <ol> <li>Create a new Rust project:</li> </ol> <pre><code>cargo init my_bdk_app\ncd my_bdk_app\n</code></pre> <ol> <li>Add <code>bdk_wallet</code> to your <code>Cargo.toml</code> file. Find the latest <code>bdk_wallet</code> release on crates.io, for example:</li> </ol> <pre><code>cargo add bdk_wallet@1.0.0-alpha.13\n</code></pre> <ol> <li>Add other required dependencies:</li> </ol> <pre><code>cargo add bdk_electrum@0.15.0\ncargo add bdk_sqlite@0.2.0\n</code></pre> <p>Follow the Sync a Wallet with Electrum page for a simple example of how to create and sync a wallet.</p>"},{"location":"getting-started/organization/","title":"Project Organization","text":"<p>Within the <code>bitcoindevkit</code> GitHub organization, the BDK team maintains a suite of Rust crates which provide both easy-to-use high level APIs and powerful lower level components to use when building more advanced bitcoin software.</p>"},{"location":"getting-started/organization/#source-code","title":"Source Code","text":"<p>The core project is split up into several crates in the <code>bdk/crates</code> directory:</p> <ul> <li><code>bdk_wallet</code>: Contains the central high level <code>Wallet</code> type    that is built from the low-level mechanisms provided by the other components.</li> <li><code>bdk_chain</code>: Tools for storing and indexing chain data.</li> <li><code>bdk_file_store</code>: A persistence backend for storing chain data in a single file.</li> <li><code>bdk_sqlite</code>: A simple SQLite relational database client for persisting bdk_chain data.</li> <li><code>bdk_esplora</code>: Extends the <code>esplora-client</code>    crate with methods to fetch chain data from an esplora HTTP server in the form that    <code>bdk_chain</code> and <code>Wallet</code> can consume.</li> <li><code>bdk_electrum</code>: Extends the <code>electrum-client</code>    crate with methods to fetch chain data from an electrum server in the form that    <code>bdk_chain</code> and <code>Wallet</code> can consume.</li> </ul>"},{"location":"getting-started/why-book/","title":"Who Is This Book For?","text":"<p>The purpose of this book is to give a strong overview of the Bitcoin Development Kit family of libraries and how they can be used together to build production-grade bitcoin applications. We aim to provide a good understanding of how to leverage our libraries together, expose the options available to developers in terms of blockchain clients and persistence layers, as well as ways they can go deeper into lower-level crates if their needs are not met by the high-level APIs exposed in the <code>bdk_wallet</code> library.</p> <p>Finally, the book is meant to get developers up to speed on general concepts pertaining to the BDK architecture as well as concrete examples of how to use our APIs in the different languages for which we provide language bindings libraries.</p> <p>What this book is not:</p> <ul> <li>API documentation, nor a comprehensive listing of all APIs available in BDK libraries. We maintain API docs on all our libraries for that purpose.</li> <li>A place to learn about core bitcoin concepts (PSBTs, UTXOs, Electrum protocol, BIPs, etc.). We provide links to great resources on these topics where appropriate.</li> <li>A comprehensive treatment of the tradeoff space developers face when building bitcoin applications (Esplora protocol vs compact block filters, onchain vs layer 2s, secure elements on mobile devices, etc.).</li> </ul>"}]}